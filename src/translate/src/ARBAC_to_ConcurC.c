#include "ARBACExact.h"
#include <time.h>

#define TYPE "_Bool"

static char *and_op = "&&";
static char *or_op = "||";

static int NumBits(int pc) {
    int i = 1, bit = 0;

    if (pc <= 2 ) return 1;

    while (pc >= i) {
        i = i * 2;
        bit++;
    }

    return (bit);
}


static void
generate_header(FILE *outputFile, char *inputFile, int rounds, int steps) {
	time_t mytime;
    mytime = time(NULL);
	fprintf(outputFile, "/*\n");
	fprintf(outputFile, "*  generated by VAC [ 0000 / 0000 ]\n");
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*  instance version    {}\n");
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*  %s\n", ctime(&mytime));
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*  params:\n");
	fprintf(outputFile, "*    %s, --rounds %d --steps %d\n", inputFile, rounds, steps);
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*/\n");

	fprintf(outputFile, "\n\n");

	fprintf(outputFile, "#include <assert.h>\n");
	fprintf(outputFile, "#define THREADS %d\n", user_array_size);
    fprintf(outputFile, "#define ROUNDS %d\n", rounds);
	fprintf(outputFile, "#define STEPS %d\n", steps);
	// fprintf(outputFile, "#define STOP_VOID(A) return;\n");
	// fprintf(outputFile, "#define STOP_NONVOID(A) return;\n");
	fprintf(outputFile, "// #define IF(T,A,B) if (__cs_pc != A) goto B;\n");
	
    // fprintf(outputFile, "#define IF(T,A,B,E) if (((__cs_pc1 != A) && (__cs_pc2 != A)) || (!(E)) ) goto B;\n");

    fprintf(outputFile, "#define IF(PC,NPC,COND,APPL) if (");
    fprintf(outputFile, "((__cs_pc%d != PC)", 0);
    for (int i = 1; i < steps; ++i)
    {
        fprintf(outputFile, " %s (__cs_pc%d != PC)", and_op, i);
    }
    fprintf(outputFile, ") || (!(COND)) ) { goto NPC; } APPL;\n");

	// fprintf(outputFile, "#ifndef NULL\n");
	// fprintf(outputFile, "#define NULL 0\n");
	// fprintf(outputFile, "#endif	\n");

	// fprintf(outputFile, "void __VERIFIER_error();\n");

	fprintf(outputFile, "\n");

	int nbits = NumBits(ca_array_size + cr_array_size + 2);

	fprintf(outputFile, "__CPROVER_bitvector[%d] nondet_bitvector();\n", nbits);

	fprintf(outputFile, "\n");

    for (int i = 0; i < steps; ++i) {
        fprintf(outputFile, "unsigned __CPROVER_bitvector[%d] __cs_pc%d;\n", nbits, i);
    }


	fprintf(outputFile, "\n");

	return;
}

static void
generate_globals(FILE *outputFile) {
	int i = 0, j = 0, flag = 0;

    fprintf(outputFile, "/*---------- INIT GLOBAL VARIABLES ---------*/\n\n");
    for (i = 0; i < admin_role_array_index_size; i++)
    {
        flag = 0;
        // Check if an admin role is already in some user
        for (j = 0; j < user_config_array_size; j++)
        {
            if (belong_to(user_config_array[j].array, user_config_array[j].array_size, admin_role_array_index[i]))
            {
                flag = 1;
                break;
            }
        }
        fprintf(outputFile, "%s glob_%s = %d;\n", TYPE, role_array[admin_role_array_index[i]], flag);
    }
    fprintf(outputFile, "\n");
}

static void
generate_locals(FILE *outputFile, char *thread_name, int thread_id) {
    fprintf(outputFile, "/*---------- THREAD %s (%d) LOCAL VARIABLES ---------*/\n\n", thread_name, thread_id);
    for (int i = 0; i < role_array_size; i++)
    {	
    	fprintf(outputFile, "    static %s local_Thread_%s_loc_%s = %d;\n", TYPE, thread_name, role_array[i], 
            belong_to(user_config_array[thread_id].array, user_config_array[thread_id].array_size, i));
    }
}

static void
generate_CA_cond(FILE *outputFile, char *thread_name, int ca_index) {
    int i, j;
    // Condition to apply a can_assign rule
    fprintf(outputFile, "        /* Precondition */\n");
    // Admin role must be available
    fprintf(outputFile, "        (glob_%s %s\n", role_array[ca_array[ca_index].admin_role_index], and_op);
    // Precondition must be satisfied
    if (ca_array[ca_index].type == 0)      // Has precondition
    {   
        if (ca_array[ca_index].positive_role_array_size > 0) {
            fprintf(outputFile, "        /* Positive preconditions */\n");
            fprintf(outputFile, "        (      local_Thread_%s_loc_%s\n", thread_name, role_array[ca_array[ca_index].positive_role_array[0]]);
            for (j = 1; j < ca_array[ca_index].positive_role_array_size; j++)
            {
                fprintf(outputFile, "            %s local_Thread_%s_loc_%s\n", and_op, thread_name, role_array[ca_array[ca_index].positive_role_array[j]]);
            }
            fprintf(outputFile, "        ) %s\n", and_op);
        }
        if (ca_array[ca_index].negative_role_array_size > 0) {
            fprintf(outputFile, "        /* Negative preconditions */\n");
            fprintf(outputFile, "        (      (!local_Thread_%s_loc_%s)\n", thread_name, role_array[ca_array[ca_index].negative_role_array[0]]);
            for (j = 1; j < ca_array[ca_index].negative_role_array_size; j++)
            {
                fprintf(outputFile, "            %s (!local_Thread_%s_loc_%s)\n", and_op, thread_name, role_array[ca_array[ca_index].negative_role_array[j]]);
            }
            fprintf(outputFile, "        ) %s\n", and_op);
        }
    }
    // Optional this user is not in this target role yet
    fprintf(outputFile, "        /* Role not assigned yet */\n");
    fprintf(outputFile, "        (!local_Thread_%s_loc_%s)\n", thread_name, role_array[ca_array[ca_index].target_role_index]);
    fprintf(outputFile, "        )");    
}

static void
generate_CR_cond(FILE *outputFile, char *thread_name, int cr_index) {
    int i, j;

    // Condition to apply a can_assign rule
    fprintf(outputFile, "        /* Precondition */\n");
    // Admin role must be available
    fprintf(outputFile, "        (glob_%s %s\n", role_array[cr_array[cr_index].admin_role_index], and_op);    
    // Optional this user is in this target role yet
    fprintf(outputFile, "        /*Role assigned*/\n");
    fprintf(outputFile, "        local_Thread_%s_loc_%s)", thread_name, role_array[cr_array[cr_index].target_role_index]);
}

static void
generate_updates(FILE *outputFile, char *thread_name) {
    fprintf(outputFile, "    /*--- GLOBAL ROLE CONSISTENCY UPDATE----*/\n");
    for (int i = 0; i < admin_role_array_index_size; i++) {
        for (int j = 0; j < cr_array_size; j++) {
                if (admin_role_array_index[i] == cr_array[j].target_role_index) {
                    char *role = role_array[admin_role_array_index[i]];
                    fprintf(outputFile, "    glob_%s = glob_%s %s local_Thread_%s_loc_%s;\n", role, role, or_op, thread_name, role);
                    break;
                }
            }
    }
    // glob_Author_d = glob_Author_d || __cs_local_Thread_user3_loc_Author_d;
}

static void
simulate_can_assign(FILE *outputFile, char *thread_name, int ca_index, int label_index) {
    fprintf(outputFile, "tThread_%s_%d:\n", thread_name, label_index);
    print_ca_comment(outputFile, ca_index);
    fprintf(outputFile, "    IF( %d,\n", label_index);
    fprintf(outputFile, "        tThread_%s_%d,\n", thread_name, label_index + 1);
    generate_CA_cond(outputFile, thread_name, ca_index);
    fprintf(outputFile, ",\n");
    if (belong_to(admin_role_array_index, admin_role_array_index_size, ca_array[ca_index].target_role_index)) {
        fprintf(outputFile, "        glob_%s = local_Thread_%s_loc_%s = 1\n", role_array[ca_array[ca_index].target_role_index], thread_name, role_array[ca_array[ca_index].target_role_index]);
    }
    else {
        fprintf(outputFile, "        local_Thread_%s_loc_%s = 1\n", thread_name, role_array[ca_array[ca_index].target_role_index]);
    }
    fprintf(outputFile, "    )\n\n");
}

static void
simulate_can_revoke(FILE *outputFile, char *thread_name, int cr_index, int label_index) {
    fprintf(outputFile, "tThread_%s_%d:\n", thread_name, label_index);
    print_cr_comment(outputFile, cr_index);
    fprintf(outputFile, "    IF( %d,\n", label_index);
    fprintf(outputFile, "        tThread_%s_%d,\n", thread_name, label_index + 1);
    generate_CR_cond(outputFile, thread_name, cr_index);
    fprintf(outputFile, ",\n");
    if (belong_to(admin_role_array_index, admin_role_array_index_size, cr_array[cr_index].target_role_index)) {
        fprintf(outputFile, "        glob_%s = local_Thread_%s_loc_%s = 0\n", role_array[cr_array[cr_index].target_role_index], thread_name, role_array[cr_array[cr_index].target_role_index]);
    }
    else {
        fprintf(outputFile, "        local_Thread_%s_loc_%s = 0\n", thread_name, role_array[cr_array[cr_index].target_role_index]);
    }
    fprintf(outputFile, "    )\n\n");
}

static void
generate_check(FILE *outputFile, char *thread_name, int label_index) {
    fprintf(outputFile, "tThread_%s_%d:\n", thread_name, label_index);
    fprintf(outputFile, "    /*---------------ERROR CHECK------------*/\n");
    fprintf(outputFile, "    if (");
    fprintf(outputFile, "local_Thread_%s_loc_%s", thread_name, role_array[goal_role_index]);
    fprintf(outputFile, ") {\n");
    fprintf(outputFile, "        assert(0);\n");
    fprintf(outputFile, "    }\n");
}

static void
generate_thread(FILE *outputFile, char *thread_name, int thread_id) {
    fprintf(outputFile, "void Thread_%s() {\n\n", thread_name);

    generate_locals(outputFile, thread_name, thread_id);

    fprintf(outputFile, "\n");
    generate_updates(outputFile, thread_name);

    int label_idx = 0;
    fprintf(outputFile, "    /*---------- IDLE ROUND ---------*/\n");
    fprintf(outputFile, "    IF(%d, tThread_%s_%d, 1, 0)\n\n", label_idx, thread_name, label_idx + 1);
    label_idx++;

    int i;
    fprintf(outputFile, "    /*---------- CAN ASSIGN SIMULATION ---------*/\n");
    for (i = 0; i < ca_array_size; i++) {
        simulate_can_assign(outputFile, thread_name, i, label_idx++);
    }

    fprintf(outputFile, "\n\n");

    fprintf(outputFile, "    /*---------- CAN REVOKE SIMULATION ---------*/\n");
    for (i = 0; i < cr_array_size; i++) {
        simulate_can_revoke(outputFile, thread_name, i, label_idx++);
    }

    generate_check(outputFile, thread_name, label_idx);
    fprintf(outputFile, "\n\n");
    fprintf(outputFile, "    return;\n");
    fprintf(outputFile, "}\n");
}

static void
generate_threads(FILE *outputFile) {
    for (int i = 0; i < user_array_size; ++i) {
        generate_thread(outputFile, user_array[i], i);
        fprintf(outputFile, "\n");
    }
}

static void
generate_thread_step(FILE *outputFile, char *thread_name, int steps) {
    fprintf(outputFile, "    /* Thread_%s */\n", thread_name);
    for (int i = 0; i < steps; ++i)
    {
        fprintf(outputFile, "    __cs_pc%d = nondet_bitvector();\n", i);
        //fprintf(outputFile, "    // __CPROVER_assume(__cs_pc%d <= %d);\n");
    }
    fprintf(outputFile, "    Thread_%s();\n", thread_name);
}

static void
generate_round(FILE *outputFile, int round, int steps) {
    fprintf(outputFile, "    /* round %d */\n", round);
    for (int i = 0; i < user_array_size; ++i) {
        generate_thread_step(outputFile, user_array[i], steps);
    }
    fprintf(outputFile, "\n");
}

static void
generate_main(FILE* outputFile, int rounds, int steps) {
    fprintf(outputFile, "int main(void) {\n");
    for (int i = 0; i < rounds; ++i)
    {
        generate_round(outputFile, i, steps);
    }
    fprintf(outputFile, "    return 0;\n");
    fprintf(outputFile, "}\n");
}

void
transform_2_lazycseq(char *inputFile, FILE *outputFile, int rounds, int steps) {

    if (rounds < 1) {
        fprintf(stderr, "Cannot simulate a number of rounds < 1\n");
        exit(EXIT_FAILURE);
    }
    if (steps < 1) {
        fprintf(stderr, "Cannot simulate a number of steps < 1\n");
        exit(EXIT_FAILURE);
    }

    
    read_ARBAC(inputFile);
    // Preprocess the ARBAC Policies
    preprocess(0);
    build_config_array();

    //Generate header with common funtions and comments
    generate_header(outputFile, inputFile, rounds, steps);
    
    //Declare variables
    generate_globals(outputFile);

    //Generate thread functions
    generate_threads(outputFile);

    //Generate Main funtion
    generate_main(outputFile, rounds, steps);

    //fclose(outputFile);
    //free(newfile);
    free_data();
    free_precise_temp_data();
}
