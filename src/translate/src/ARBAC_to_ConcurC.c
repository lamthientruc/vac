#include "ARBACExact.h"
#include <time.h>

#define TYPE "_Bool"

static char *and_op = "&&";
static char *or_op = "||";

static char *assume = "__VERIFIER_assume";

static int threads_count;
static int use_tracks;

static void
generate_header(FILE *outputFile, char *inputFile) {
	time_t mytime;
    mytime = time(NULL);
	fprintf(outputFile, "/*\n");
	fprintf(outputFile, "*  generated by VAC [ 0000 / 0000 ]\n");
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*  instance version    {}\n");
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*  %s\n", ctime(&mytime));
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*  params:\n");
    fprintf(outputFile, "*\n");
    fprintf(outputFile, "*  users: %d\n", user_array_size);
    fprintf(outputFile, "*  roles: %d\n", role_array_size);
    fprintf(outputFile, "*  adminroles: %d\n", admin_role_array_index_size);
    fprintf(outputFile, "*  CA: %d\n", ca_array_size);
    fprintf(outputFile, "*  CR: %d\n", cr_array_size);
    fprintf(outputFile, "*  ThreadCount: %d\n", threads_count);
	fprintf(outputFile, "*\n");
	fprintf(outputFile, "*/\n");

	fprintf(outputFile, "\n\n");

    fprintf(outputFile, "#include <pthread.h>\n\n");

    // fprintf(outputFile, "#include <assert.h>\n");
    fprintf(outputFile, "#define THREADS %d\n", threads_count);
	fprintf(outputFile, "#define THREADS_CONFIGURATIONS %d\n", user_array_size);

	fprintf(outputFile, "\nextern void __VERIFIER_error() __attribute__ ((__noreturn__));\n");
	fprintf(outputFile, "_Bool nondet_bool();\n");

	fprintf(outputFile, "\n");

	return;
}

static void
generate_globals(FILE *outputFile) {
	int i = 0, j = 0, flag = 0;

    fprintf(outputFile, "/*---------- DEFINE AND INIT GLOBAL VARIABLES ---------*/\n\n");
    for (i = 0; i < admin_role_array_index_size; i++)
    {
        flag = 0;
        // Check if an admin role is already in some user
        for (j = 0; j < user_config_array_size; j++)
        {
            if (belong_to(user_config_array[j].array, user_config_array[j].array_size, admin_role_array_index[i]))
            {
                flag = 1;
                break;
            }
        }
        fprintf(outputFile, "%s glob_%s = %d;\n", TYPE, role_array[admin_role_array_index[i]], flag);
    }
    fprintf(outputFile, "\n");
}

static void
generate_thread_locals(FILE *outputFile, int thread_id) {
    fprintf(outputFile, "\n/*---------- THREAD %d LOCAL VARIABLES ---------*/\n", thread_id);
    for (int i = 0; i < role_array_size; i++)
    {	
        if (use_tracks) {
            fprintf(outputFile, "static %s local_Thread_%d_loc_%s = %d;\n", TYPE, thread_id, role_array[i], 0);
        }
        else {
            fprintf(outputFile, "static %s local_Thread_%d_loc_%s = %d;\n", TYPE, thread_id, role_array[i], 
                belong_to(user_config_array[thread_id].array, user_config_array[thread_id].array_size, i));
        }
    }
}

static void
generate_locals(FILE *outputFile) {
    fprintf(outputFile, "/*---------- THREADS LOCAL VARIABLES ---------*/\n\n");
    for (int i = 0; i < threads_count; ++i)
    {
        generate_thread_locals(outputFile, i);
    }
}

static void
generate_CA_cond(FILE *outputFile, int thread_id, int ca_index) {
    int i, j;
    // fprintf(outputFile, "        /*Thread %d is assinged to some user*/\n", thread_id);
    // fprintf(outputFile, "        thread_%d_assigned\n", thread_id);
    // Condition to apply a can_assign rule
    fprintf(outputFile, "        /* Precondition */\n");
    // Admin role must be available
    fprintf(outputFile, "        (glob_%s %s\n", role_array[ca_array[ca_index].admin_role_index], and_op);
    // Precondition must be satisfied
    if (ca_array[ca_index].type == 0)      // Has precondition
    {   
        if (ca_array[ca_index].positive_role_array_size > 0) {
            fprintf(outputFile, "        /* Positive preconditions */\n");
            fprintf(outputFile, "        (      local_Thread_%d_loc_%s\n", thread_id, role_array[ca_array[ca_index].positive_role_array[0]]);
            for (j = 1; j < ca_array[ca_index].positive_role_array_size; j++)
            {
                fprintf(outputFile, "            %s local_Thread_%d_loc_%s\n", and_op, thread_id, role_array[ca_array[ca_index].positive_role_array[j]]);
            }
            fprintf(outputFile, "        ) %s\n", and_op);
        }
        if (ca_array[ca_index].negative_role_array_size > 0) {
            fprintf(outputFile, "        /* Negative preconditions */\n");
            fprintf(outputFile, "        (      (!local_Thread_%d_loc_%s)\n", thread_id, role_array[ca_array[ca_index].negative_role_array[0]]);
            for (j = 1; j < ca_array[ca_index].negative_role_array_size; j++)
            {
                fprintf(outputFile, "            %s (!local_Thread_%d_loc_%s)\n", and_op, thread_id, role_array[ca_array[ca_index].negative_role_array[j]]);
            }
            fprintf(outputFile, "        ) %s\n", and_op);
        }
    }
    // Optional this user is not in this target role yet
    fprintf(outputFile, "        /* Role not assigned yet */\n");
    fprintf(outputFile, "        (!local_Thread_%d_loc_%s)\n", thread_id, role_array[ca_array[ca_index].target_role_index]);
    fprintf(outputFile, "        )");    
}

static void
generate_CR_cond(FILE *outputFile, int thread_id, int cr_index) {
    int i, j;
    // fprintf(outputFile, "        /*Thread %d is assinged to some user*/\n", thread_id);
    // fprintf(outputFile, "        thread_%d_assigned\n", thread_id);
    // Condition to apply a can_assign rule
    fprintf(outputFile, "        /* Precondition */\n");
    // Admin role must be available
    fprintf(outputFile, "        (glob_%s %s\n", role_array[cr_array[cr_index].admin_role_index], and_op);    
    // Optional this user is in this target role yet
    fprintf(outputFile, "        /*Role assigned*/\n");
    fprintf(outputFile, "        local_Thread_%d_loc_%s)", thread_id, role_array[cr_array[cr_index].target_role_index]);
}

static void
generate_updates(FILE *outputFile, int thread_id) {
    fprintf(outputFile, "    /*--- GLOBAL ROLE CONSISTENCY UPDATE----*/\n");
    for (int i = 0; i < admin_role_array_index_size; i++) {
        for (int j = 0; j < cr_array_size; j++) {
                if (admin_role_array_index[i] == cr_array[j].target_role_index) {
                    char *role = role_array[admin_role_array_index[i]];
                    fprintf(outputFile, "    glob_%s = glob_%s %s local_Thread_%d_loc_%s;\n", role, role, or_op, thread_id, role);
                    break;
                }
            }
    }
    // glob_Author_d = glob_Author_d || __cs_local_Thread_user3_loc_Author_d;
}

static void
simulate_can_assign(FILE *outputFile, int thread_id, int ca_index) {
    print_ca_comment(outputFile, ca_index);
    fprintf(outputFile, "    if( nondet_bool() &&\n");
    generate_CA_cond(outputFile, thread_id, ca_index);
    fprintf(outputFile, ") {\n");
    if (belong_to(admin_role_array_index, admin_role_array_index_size, ca_array[ca_index].target_role_index)) {
        fprintf(outputFile, "        glob_%s = local_Thread_%d_loc_%s = 1;\n", role_array[ca_array[ca_index].target_role_index], thread_id, role_array[ca_array[ca_index].target_role_index]);
    }
    else {
        fprintf(outputFile, "        local_Thread_%d_loc_%s = 1;\n", thread_id, role_array[ca_array[ca_index].target_role_index]);
    }
    fprintf(outputFile, "    }\n\n");
}

static void
simulate_can_revoke(FILE *outputFile, int thread_id, int cr_index) {
    print_cr_comment(outputFile, cr_index);
    fprintf(outputFile, "    if( nondet_bool() &&\n");
    generate_CR_cond(outputFile, thread_id, cr_index);
    fprintf(outputFile, ") {\n");
    if (belong_to(admin_role_array_index, admin_role_array_index_size, cr_array[cr_index].target_role_index)) {
        fprintf(outputFile, "        glob_%s = local_Thread_%d_loc_%s = 0;\n", role_array[cr_array[cr_index].target_role_index], thread_id, role_array[cr_array[cr_index].target_role_index]);
    }
    else {
        fprintf(outputFile, "        local_Thread_%d_loc_%s = 0;\n", thread_id, role_array[cr_array[cr_index].target_role_index]);
    }
    fprintf(outputFile, "    }\n\n");
}

static void
generate_check(FILE *outputFile, int thread_id) {
    fprintf(outputFile, "    /*---------------ERROR CHECK------------*/\n");
    fprintf(outputFile, "    if (");
    fprintf(outputFile, "local_Thread_%d_loc_%s", thread_id, role_array[goal_role_index]);
    fprintf(outputFile, ") {\n");
    fprintf(outputFile, "        assert(0);\n");
    fprintf(outputFile, "    }\n");
}

static void
generate_thread(FILE *outputFile, int thread_id) {
    fprintf(outputFile, "void *Thread_%d(void *args) {\n\n", thread_id);

    // Not used anymore since is declared at top level
    // generate_locals(outputFile, thread_id, thread_id);
    // fprintf(outputFile, "\n");
    
    generate_updates(outputFile, thread_id);

    fprintf(outputFile, "  while (1) {\n");
    fprintf(outputFile, "    /*---------- CAN ASSIGN SIMULATION ---------*/\n");
    for (int i = 0; i < ca_array_size; i++) {
        fprintf(outputFile, "__VERIFIER_atomic_begin();\n");
        simulate_can_assign(outputFile, thread_id, i);
        fprintf(outputFile, "__VERIFIER_atomic_end();\n");
    }

    fprintf(outputFile, "\n\n");

    fprintf(outputFile, "    /*---------- CAN REVOKE SIMULATION ---------*/\n");
    for (int i = 0; i < cr_array_size; i++) {
        fprintf(outputFile, "__VERIFIER_atomic_begin();\n");
        simulate_can_revoke(outputFile, thread_id, i);
        fprintf(outputFile, "__VERIFIER_atomic_end();\n");
    }

    generate_check(outputFile, thread_id);
    fprintf(outputFile, "  }\n\n");
    fprintf(outputFile, "  return;\n");
    fprintf(outputFile, "}\n");
}

static void
generate_threads(FILE *outputFile) {
    for (int i = 0; i < threads_count; ++i) {
        generate_thread(outputFile, i);
        fprintf(outputFile, "\n");
    }
}

static void
initialize_threads_locals(FILE *outputFile) {
    fprintf(outputFile, "/*--------------- THREAD ASSIGNMENT LOCAL VARIABLES ------------*/\n");
    for (int i = 0; i < threads_count; ++i) {
        fprintf(outputFile, "%s thread_%d_assigned = 0;\n", TYPE, i);
    }
}

static void
initialize_threads_assignments(FILE *outputFile, int user_id)
{
    int i, j;

    fprintf(outputFile, "    /*--------------- CONFIGURATION OF %s ------------*/\n", user_array[user_id]);

    fprintf(outputFile, "    if (nondet_bool()) {\n");

    for (i = 0; i < threads_count; i++) {
        if (i == 0) {
            fprintf(outputFile, "        if (!thread_%d_assigned) {\n", i);
        }
        else {
            fprintf(outputFile, "        else if (!thread_%d_assigned) {\n", i);
        }

        fprintf(outputFile, "            thread_%d_assigned = 1;\n", i);

        for (j = 0; j < user_config_array[user_id].array_size; j++)
        {
            fprintf(outputFile, "            local_Thread_%d_loc_%s = 1;\n", i, role_array[user_config_array[user_id].array[j]]);
        }
        fprintf(outputFile, "        }\n");
    }
    fprintf(outputFile, "    }\n\n");
}

static void
initialize_threads(FILE *outputFile) {
    int i;
    fprintf(outputFile, "void initialize_threads() {\n");

    for (i = 0; i < user_array_size; ++i) {
        initialize_threads_assignments(outputFile, i);
    }

    fprintf(outputFile, "    %s(\n", assume);
    
    for (i = 0; i < threads_count - 1; ++i) { 
        fprintf(outputFile, "        thread_%d_assigned %s\n", i, and_op);
    }
    fprintf(outputFile, "        thread_%d_assigned);\n", i);

    fprintf(outputFile, "}\n\n");
}

static void
generate_main(FILE* outputFile) {
    fprintf(outputFile, "int main(void) {\n\n");

    fprintf(outputFile, "    /*------------ THREAD DEFINITION -----------*/\n");
    fprintf(outputFile, "    pthread_t th_%d", 0);
    for (int i = 1; i < threads_count; ++i) {
        fprintf(outputFile, ", th_%d", i);
    }
    fprintf(outputFile, ";\n\n");

    if (use_tracks) {
        fprintf(outputFile, "    /*------------ THREAD LOCALS INITIALIZATION -----------*/\n");
        fprintf(outputFile, "    initialize_threads();\n\n");
    }

    fprintf(outputFile, "    /*------------ THREAD SPAWN -----------*/\n");
    for (int i = 0; i < threads_count; ++i) {
        fprintf(outputFile, "    pthread_create(&th_%d, 0, Thread_%d, 0);\n", i, i);
    }

    // fprintf(outputFile, "    /*------------ THREAD JOIN (REALLY NEEDED?) -----------*/\n");
    // for (int i = 0; i < threads_count; ++i) {
    //     fprintf(outputFile, "    pthread_join(th_%d, 0);\n", i);
    // }

    fprintf(outputFile, "    return 0;\n");
    fprintf(outputFile, "}\n");
}

void
transform_2_concurC(char *inputFile, FILE *outputFile, int wanted_threads_count) {

    
    read_ARBAC(inputFile);
    // Preprocess the ARBAC Policies
    preprocess(0);
    build_config_array();
    //Set the number of user to track
    if (wanted_threads_count < 1) {
        if (user_array_size <= admin_role_array_index_size + 1) {
            threads_count = user_array_size;
            use_tracks = 0;
        }
        else {
            threads_count = admin_role_array_index_size + 1;
            use_tracks = 1;
        }
    }
    else {
        if (user_array_size <= wanted_threads_count) {
            fprintf(stderr, "Cannot spawn %d threads because are more than user count (%d)\n", wanted_threads_count, user_array_size);
            exit(EXIT_FAILURE);
        }
        else {
            threads_count = admin_role_array_index_size + 1;
            use_tracks = 1;
        }   
    }

    //Generate header with common funtions and comments
    generate_header(outputFile, inputFile);
    
    //Declare global variables
    generate_globals(outputFile);

    //Declare threads local variables
    generate_locals(outputFile);

    if (use_tracks) {
        //Declare thread initialization variables
        initialize_threads_locals(outputFile);
        initialize_threads(outputFile);
    }

    //Generate thread functions
    generate_threads(outputFile);

    //Generate Main funtion
    generate_main(outputFile);

    //fclose(outputFile);
    //free(newfile);
    free_data();
    free_precise_temp_data();
}
