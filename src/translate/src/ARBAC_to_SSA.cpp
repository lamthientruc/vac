#include "ARBACExact.h"
#include <time.h>

#define TYPE "_Bool"

#define emit fprintf
#define true "TRUE"
#define false "FALSE"

static char *and_op = "&&";
static char *or_op = "||";
static char *ass_op = "=";
static char *nondet_op = "nondet_symbol()";

static char *assume = "__VERIFIER_assume";

static int threads_count;
static int use_tracks;

/*--- SSA VARIABLE INDEXES ---*/
/*--- VALUES ARE  ---*/
static int *globals;
static int *thread_assigneds;
static int *program_counters;
static int **locals;
static int guard;
static int nondet_bool;
static int steps;

static char *
has_role(int * array, int array_size, int index) {
    return belong_to(array, array_size, index) ? true : false;
}

static void
initialize_var_counters() {

    guard = 0;
    nondet_bool = 0;

    globals = (int*) calloc(sizeof(int), admin_role_array_index_size);
    for (int i = 0; i < admin_role_array_index_size; ++i) {
        globals[i] = 0;    
    }

    thread_assigneds = (int*) calloc(sizeof(int), threads_count);
    for (int i = 0; i < threads_count; ++i) {
        thread_assigneds[i] = 0;    
    }

    program_counters = (int*) calloc(sizeof(int), steps);
    for (int i = 0; i < steps; ++i) {
        program_counters[i] = 0;    
    }

    locals = (int**) calloc(sizeof(int), threads_count);
    for (int i = 0; i < threads_count; ++i) {
        locals[i] = (int*) calloc(sizeof(int), role_array_size);
        for (int j = 0; j < role_array_size; ++j) {
            locals[i][j] = 0;
        }
    }
}

static void
free_var_counters() {
    for (int i = 0; i < threads_count; ++i) {
        free(locals[i]);
    }
    free(locals);
    free(globals);
    free(thread_assigneds);
    free(program_counters);
}

static void
generate_header(FILE *outputFile, char *inputFile, int rounds, int steps) {
    time_t mytime;
    mytime = time(NULL);
    fprintf(outputFile, "/*\n");
    fprintf(outputFile, "*  generated by VAC [ 0000 / 0000 ]\n");
    fprintf(outputFile, "*\n");
    fprintf(outputFile, "*  instance version    {}\n");
    fprintf(outputFile, "*\n");
    fprintf(outputFile, "*  %s\n", ctime(&mytime));
    fprintf(outputFile, "*\n");
    fprintf(outputFile, "*  params:\n");
    fprintf(outputFile, "*    %s, --format ssa --rounds %d --steps %d\n", inputFile, rounds, steps);
    fprintf(outputFile, "*\n");
    fprintf(outputFile, "*  users: %d\n", user_array_size);
    fprintf(outputFile, "*  roles: %d\n", role_array_size);
    fprintf(outputFile, "*  adminroles: %d\n", admin_role_array_index_size);
    fprintf(outputFile, "*  CA: %d\n", ca_array_size);
    fprintf(outputFile, "*  CR: %d\n", cr_array_size);
    fprintf(outputFile, "*  ThreadCount: %d\n", threads_count);
    fprintf(outputFile, "*\n");
    fprintf(outputFile, "*/\n");

    fprintf(outputFile, "\n\n");

    fprintf(outputFile, "__ESBMC_rounding_mode&0#1 == 0\n");

    return;
}

// static void 
// first_init(FILE *outputFile) {
//     int i = 0, j = 0;
//     char *count = 0;

//     fprintf(outputFile, "/*---------- INIT GLOBAL VARIABLES ---------*/\n\n");
//     for (i = 0; i < admin_role_array_index_size; i++)
//     {
//         count = false;
//         // Check if an admin role is already in some user
//         for (j = 0; j < user_config_array_size; j++)
//         {
//             if (belong_to(user_config_array[j].array, user_config_array[j].array_size, admin_role_array_index[i])) {
//                 count = true;
//                 break;
//             }
//         }
//         fprintf(outputFile, "glob_%s_%d %s %s;\n", role_array[admin_role_array_index[i]], ++globals[i], ass_op, count);
//     }
//     fprintf(outputFile, "\n");
// }

// static void
// generate_thread_locals(FILE *outputFile, int thread_id) {
//     fprintf(outputFile, "\n/*---------- THREAD %d LOCAL VARIABLES ---------*/\n", thread_id);
//     for (int i = 0; i < role_array_size; i++)
//     {   
//         if (use_tracks) {
//             //fprintf(outputFile, "local_Thread_%d_loc_%s_%d %s %s;\n", thread_id, role_array[i], locals[thread_id][i], ass_op, false);
//         }
//         else {
//             fprintf(outputFile, "local_Thread_%d_loc_%s_%d %s %s;\n", thread_id, role_array[i], ++locals[thread_id][i], ass_op, 
//                 has_role(user_config_array[thread_id].array, user_config_array[thread_id].array_size, i));
//         }
//     }
// }

// static void
// assign_one_threads(FILE *outputFile, int thread_id, int user_id) {
//     fprintf(outputFile, "nondet_bool_%d %s %s\n", ++nondet_bool, ass_op, nondet_op);
    
//     for (j = 0; j < user_config_array[user_id].array_size; j++) {
//         fprintf(outputFile, "local_Thread_%d_loc_%s_%d %s %d;\n", i, role_array[user_config_array[user_id].array[j]]);
//     }
// }

// static void
// initialize_threads_assignments(FILE *outputFile, int user_id)
// {
//     int i, j;

//     fprintf(outputFile, "    /*--------------- CONFIGURATION OF %s ------------*/\n", user_array[user_id]);

//     // fprintf(outputFile, "    if (nondet_bool()) {\n");

//     for (i = 0; i < threads_count; i++) {
//         if (i == 0) {
//             fprintf(outputFile, "    if (nondet_bool() %s !thread_%d_assigned) {\n", and_op, i);
//         }
//         else {
//             fprintf(outputFile, "    else if (nondet_bool() %s !thread_%d_assigned) {\n", and_op, i);
//         }

//         fprintf(outputFile, "        thread_%d_assigned = 1;\n", i);

//         for (j = 0; j < user_config_array[user_id].array_size; j++) {
//             #ifndef GLOBALS_ALL_USERS
//             // if GLOBALS_ALL_USERS is NOT set than we have to set the globals for this role
//             if (belong_to(admin_role_array_index, admin_role_array_index_size, user_config_array[user_id].array[j])) {
//                 #ifdef GLOBALS_INT
//                 fprintf(outputFile, "        glob_%s++;\n", role_array[user_config_array[user_id].array[j]]);
//                 #else
//                 fprintf(outputFile, "        glob_%s = 1;\n", role_array[user_config_array[user_id].array[j]]);
//                 #endif
//             }
//             #endif
//             fprintf(outputFile, "        local_Thread_%d_loc_%s = 1;\n", i, role_array[user_config_array[user_id].array[j]]);
//         }
//         fprintf(outputFile, "    }\n\n");
//     }
//     // fprintf(outputFile, "    }\n\n");
// }

// static void
// initialize_threads(FILE *outputFile) {
//     int i;
//     fprintf(outputFile, "void initialize_threads() {\n");

//     for (i = 0; i < user_array_size; ++i) {
//         initialize_threads_assignments(outputFile, i);
//     }

//     fprintf(outputFile, "    %s(\n", assume);
    
//     for (i = 0; i < threads_count - 1; ++i) { 
//         fprintf(outputFile, "        thread_%d_assigned %s\n", i, and_op);
//     }
//     fprintf(outputFile, "        thread_%d_assigned);\n", i);

//     fprintf(outputFile, "}\n\n");
// }

void
transform_2_ssa(char *inputFile, FILE *outputFile, int rounds, int _steps, int wanted_threads_count) {

    if (rounds < 1) {
        fprintf(stderr, "Cannot simulate a number of rounds < 1\n");
        exit(EXIT_FAILURE);
    }
    if (steps < 1) {
        fprintf(stderr, "Cannot simulate a number of steps < 1\n");
        exit(EXIT_FAILURE);
    }
    
    read_ARBAC(inputFile);
    // Preprocess the ARBAC Policies
    preprocess(0);
    build_config_array();

    //Set the number of user to track
    if (wanted_threads_count < 1) {
        if (user_array_size <= admin_role_array_index_size + 1) {
            threads_count = user_array_size;
            use_tracks = 0;
        }
        else {
            threads_count = admin_role_array_index_size + 1;
            use_tracks = 1;
        }
    }
    else {
        if (user_array_size <= wanted_threads_count) {
            fprintf(stderr, "Cannot spawn %d threads because are more than user count (%d)\n", wanted_threads_count, user_array_size);
            exit(EXIT_FAILURE);
        }
        else {
            threads_count = admin_role_array_index_size + 1;
            use_tracks = 1;
        }   
    }

    steps = _steps;

    //Generate header with common funtions and comments
    generate_header(outputFile, inputFile, rounds, steps);
    
    

    free_data();
    free_precise_temp_data();
    free_var_counters();
}
